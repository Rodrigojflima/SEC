// AnnouncementServerProxy

    public List<String> post(String publicKey, String message, List<String> announcementList, String signature)
            throws UserNotRegisteredException, MessageSizeException, ReferredUserException, PostTypeException,
            ReferredAnnouncementException {
        return AnnouncementServer.getInstance().post(publicKey, message, announcementList, signature);
    }

    public List<String> postGeneral(String publicKey, String message, List<String> announcementList, String signature)
            throws UserNotRegisteredException, MessageSizeException, ReferredUserException,
            ReferredAnnouncementException, PostTypeException {
        return AnnouncementServer.getInstance().postGeneral(publicKey, message, announcementList, signature);
    }

    public List<String> read(String readerKey, String publicKey, Long number, String signature)
            throws InvalidNumberException, ReferredUserException, EmptyBoardException, NumberPostsException,
            UserNotRegisteredException {
        return AnnouncementServer.getInstance().read(readerKey, publicKey, number, signature);
    }

    public List<String> readGeneral(String readerKey, Long number, String signature)
            throws InvalidNumberException, EmptyBoardException, NumberPostsException {
        return AnnouncementServer.getInstance().readGeneral(readerKey, number, signature);
    }



// AnnouncementServer.java
	/* Post */
	public List<String> post(String publicKey, String message, List<String> announcementList, String signature) 
			throws UserNotRegisteredException, MessageSizeException, ReferredUserException, PostTypeException, ReferredAnnouncementException {
		
		/* ---------------------------- Verify signature ----------------------------------*/

		Integer sn = sns.get(clients.get(publicKey));
		
		String clientID = String.format("client%d", clients.get(publicKey));
		String hash = null;
		
		try {
			hash = CryptoTools.decryptSignature(clientID, signature);
		} catch (Exception e) {
			throw new RuntimeException(e.getMessage());
		}
		
		List<String> inHash = new ArrayList<>();
		inHash.add(clientID);
		inHash.add(myId);
		inHash.add(sn.toString());
		inHash.add(publicKey);
		inHash.add(message);
		inHash.addAll(announcementList);
		inHash.add(hash);
		
		try{
			if (!CryptoTools.checkHash(inHash.toArray(new String[0]))) { 
				throw new RuntimeException("Error: Possible tampering detected");
			}
		} catch (Exception e) {
			throw new RuntimeException(e.getMessage());
		}

		/* -----------------------------------------------------------------------------------*/

		/* ---------------------------- Application Behavior ----------------------------------*/

		/* Verify existence of publicKey */
		if (!personalBoards.containsKey(publicKey))  {
			throw new UserNotRegisteredException("User is not registered yet");
		}
		
		/* Verify correct size of message */
		if (message.length() > 255) {
			throw new MessageSizeException("Too many characters in the message (max:255)");
		}
		
		ArrayList<Announcement> board = personalBoards.get(publicKey);
		Announcement post = new Announcement();
		post.setContent(message);
		
		/* Verify structure of announcementList */
		for (String reference : announcementList) {			
			String[] parts = reference.split("a|c"); // [<p|g>, author_id, ctr_id]
			String pk = pks.get(Integer.parseInt(parts[1]));
			
			if (!personalBoards.containsKey(pk)) {
				throw new ReferredUserException("Referred user doesn't exist");
			}
			
			if (parts[0].equals("p")) {								
				if (personalBoards.get(pk).size() < Integer.parseInt(parts[2])) {
					throw new ReferredAnnouncementException("The referred announcement doesn’t exist");
				}
				
			} else if (parts[0].equals("g")) {
				if (generalBoard.size() < Integer.parseInt(parts[2])) {
					throw new ReferredAnnouncementException("The referred announcement doesn’t exist");
				}
			} else {
				throw new PostTypeException("The type of post in reference is incorrect");
			}
			
			
			post.addReference(reference);
		}
		
		post.setId(String.format("pc%da%d", clients.get(publicKey), board.size()));
		post.setAuthor(String.format("client%d", clients.get(publicKey)));
		
		board.add(post);
		
		sns.put(clients.get(publicKey), sn + 1);
		PersistenceUtils.serialize(instance);
		

		/* -----------------------------------------------------------------------------------*/

		/* ---------------------------- Create Own Signature ---------------------------------*/

		List<String> response = new ArrayList<>();
		List<String> outHash = new ArrayList<>();
		outHash.add(myId);
		outHash.add(clientID);
		outHash.add(sn.toString());
		outHash.add("Success your post was posted!");
		
		try {
			response.add(outHash.get(3));
			response.add(CryptoTools.makeSignature(outHash.toArray(new String[0])));
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e.getMessage());
		}
		
		/* -----------------------------------------------------------------------------------*/

		return response;
	}
	
	/* Post General */
	public List<String> postGeneral(String publicKey, String message, List<String> announcementList, String signature) 
			throws UserNotRegisteredException, MessageSizeException, ReferredUserException, ReferredAnnouncementException, PostTypeException {
		
		/* ---------------------------- Verify signature ----------------------------------*/
		
		/* Verify existence of publicKey */
		Integer sn = sns.get(clients.get(publicKey));
		
		String clientID = String.format("client%d", clients.get(publicKey));
		String hash = null;
		
		try {
			hash = CryptoTools.decryptSignature(clientID, signature);
		} catch (Exception e) {
			throw new RuntimeException(e.getMessage());
		}
		
		List<String> inHash = new ArrayList<>();
		inHash.add(clientID);
		inHash.add(myId);
		inHash.add(sn.toString());
		inHash.add(publicKey);
		inHash.add(message);
		inHash.addAll(announcementList);
		inHash.add(hash);
		
		try{
			if (!CryptoTools.checkHash(inHash.toArray(new String[0]))) { 
				throw new RuntimeException("Error: Possible tampering detected");
			}
		} catch (Exception e) {
			throw new RuntimeException(e.getMessage());
		}
		
		/* -----------------------------------------------------------------------------------*/

		/* ---------------------------- Application Behavior ----------------------------------*/

		if (!personalBoards.containsKey(publicKey))  {
			throw new UserNotRegisteredException("User is not registered yet");
		}
		
		/* Verify correct size of message */
		if (message.length() > 255) {
			throw new MessageSizeException("Too many characters in the message (max:255)");
		}

		Announcement post = new Announcement();
		
		/* Verify structure of announcementList */
		for (String reference : announcementList) {
			String[] parts = reference.split("a|c"); // [<p|g>, author_id, ctr_id]
			String pk = pks.get(Integer.parseInt(parts[1]));
			
			if (!personalBoards.containsKey(pk)) {
				throw new ReferredUserException("Referred user doesn't exist");
			}
			
			if (parts[0].equals("p")) {								
				if (personalBoards.get(pk).size() < Integer.parseInt(parts[2])) {
					throw new ReferredAnnouncementException("The referred announcement doesn’t exist");
				}
				
			} else if (parts[0].equals("g")) {
				if (generalBoard.size() < Integer.parseInt(parts[2])) {
					throw new ReferredAnnouncementException("The referred announcement doesn’t exist");
				}
			} else {
				throw new PostTypeException("The type of post in reference is incorrect");
			}
			
			post.addReference(reference);
		}

		post.setContent(message);
		post.setId(String.format("gc%da%d", clients.get(publicKey), generalBoard.size()));
		post.setAuthor(String.format("client%d", clients.get(publicKey)));
		
		generalBoard.add(post);
		
		sns.put(clients.get(publicKey), sn + 1);
		PersistenceUtils.serialize(instance);
		
		/* -----------------------------------------------------------------------------------*/

		/* ---------------------------- Create Own Signature ---------------------------------*/
		
		List<String> response = new ArrayList<>();
		List<String> outHash = new ArrayList<>();
		outHash.add(myId);
		outHash.add(clientID);
		outHash.add(sn.toString());
		outHash.add("Success your post was posted!");
		
		try {
			response.add(outHash.get(3));
			response.add(CryptoTools.makeSignature(outHash.toArray(new String[0])));
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e.getMessage());
		}
		
		/* -----------------------------------------------------------------------------------*/

		return response;
	}
	
	/* Read */
	public List<String> read(String readerKey, String publicKey, Long number, String signature) 
			throws InvalidNumberException, ReferredUserException, EmptyBoardException, NumberPostsException,
			UserNotRegisteredException {
		//number and PublicKey enough to find a post in PersonalBoards
		
		/* ---------------------------- Verify signature ----------------------------------*/

		Integer sn = sns.get(clients.get(readerKey));
		String readerID = String.format("client%d", clients.get(readerKey));
		
		String hash = null;

		try {
			hash = CryptoTools.decryptSignature(readerID, signature);
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e.getMessage());
		}

		List<String> inHash = new ArrayList<>();
		inHash.add(readerID);
		inHash.add(myId);
		inHash.add(sn.toString());
		inHash.add(publicKey);
		inHash.add(number.toString());
		inHash.add(hash);
		System.out.println(inHash);
		try{
			if (!CryptoTools.checkHash(inHash.toArray(new String[0]))) { 
				throw new RuntimeException("Error: Possible tampering detected");
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e.getMessage());
		}

		/* -----------------------------------------------------------------------------------*/

		/* ---------------------------- Application Behavior ----------------------------------*/

		if (!personalBoards.containsKey(publicKey))  {
			throw new RuntimeException("User is not registered yet");
		}
				
		ArrayList<Announcement> board = personalBoards.get(publicKey); //get the personal board
		
		if (board.isEmpty()) throw new EmptyBoardException("The board has no posts");
		
		if (number > board.size()) throw new NumberPostsException("The board doesn't have that many posts");

		String res = "";      //save the posts you want to see
		int end = board.size() - 1;
		
		Long limit = (number == 0) ? board.size() : number;
		
		for(int i = 0; i < limit; i++) {
			res += board.get(end - i).toString();
		}

		sns.put(clients.get(publicKey), sn + 1);
		PersistenceUtils.serialize(instance);

		/* -----------------------------------------------------------------------------------*/

		/* ---------------------------- Create Own Signature ---------------------------------*/
		
		List<String> response = new ArrayList<>();
		List<String> outHash = new ArrayList<>();
		outHash.add(myId);
		outHash.add(readerID);
		outHash.add(sn.toString());
		outHash.add(res);
		
		try {
			response.add(res);
			response.add(CryptoTools.makeSignature(outHash.toArray(new String[0])));
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e.getMessage());
		}
		
		/* -----------------------------------------------------------------------------------*/

		return response;
	}
	
	/* Read General */
	public List<String> readGeneral(String readerKey, Long number, String signature) 
			throws InvalidNumberException, EmptyBoardException, NumberPostsException {
		//number and PublicKey enough to find a post in GeneralBoard

		/* ---------------------------- Verify signature ----------------------------------*/
		
		Integer sn = sns.get(clients.get(readerKey));
		String readerID = String.format("client%d", clients.get(readerKey));
		
		String hash = null;

		try {
			hash = CryptoTools.decryptSignature(readerID, signature);
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e.getMessage());
		}
		
		List<String> inHash = new ArrayList<>();
		inHash.add(readerID);
		inHash.add(myId);
		inHash.add(sn.toString());
		inHash.add(number.toString());
		inHash.add(hash);
		
		try{
			if (!CryptoTools.checkHash(inHash.toArray(new String[0]))) { 
				throw new RuntimeException("Error: Possible tampering detected");
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e.getMessage());
		}

		/* -----------------------------------------------------------------------------------*/

		/* ---------------------------- Application Behavior ----------------------------------*/

		if (number < 0) throw new InvalidNumberException("Invalid number");
		
		if (generalBoard.isEmpty()) throw new EmptyBoardException("The board has no posts");
		
		if (number > generalBoard.size()) throw new NumberPostsException("The board doesn't have that many posts");

		String res = "";      //save the posts you want to see
		int end = generalBoard.size() - 1;
		
		Long limit = (number == 0) ? generalBoard.size() : number;
		
		for(int i = 0; i < limit; i++) {
			res += generalBoard.get(end - i).toString();
		}

		sns.put(clients.get(readerKey), sn + 1);
		PersistenceUtils.serialize(instance);

		/* -----------------------------------------------------------------------------------*/

		/* ---------------------------- Create Own Signature ---------------------------------*/

		List<String> response = new ArrayList<>();
		List<String> outHash = new ArrayList<>();
		outHash.add(myId);
		outHash.add(readerID);
		outHash.add(sn.toString());
		outHash.add(res);
		
		try {
			response.add(res);
			response.add(CryptoTools.makeSignature(outHash.toArray(new String[0])));
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e.getMessage());
		}
		
		/* -----------------------------------------------------------------------------------*/

		System.out.println("READ GENERAL DONE");
		return response;
	}
